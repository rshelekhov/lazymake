# lazymake Configuration Example
#
# Place this file as:
# - ~/.lazymake.yaml for global configuration
# - ./.lazymake.yaml for project-specific configuration
#
# Global and project configs are merged (applies to safety, export, shell_integration):
# - Scalars (enabled, format, shell, etc.): project overrides global
# - String lists (enabled_rules, exclude_targets): union, deduplicated
# - Struct lists (custom_rules): appended (global + project)

# Makefile path (default: auto-detect GNUmakefile, makefile, Makefile)
# When empty, lazymake searches in GNU make order: GNUmakefile → makefile → Makefile
# makefile: Makefile

# Safety Features Configuration
safety:
  # Master switch - enable/disable all safety checks
  # Default: true (enabled by default to protect newcomers)
  enabled: true

  # Exclude specific targets from ALL safety checks
  # Useful for targets you run frequently and trust completely
  exclude_targets:
    - clean          # Standard cleanup target
    - distclean      # Deep cleanup
    - reset-dev-db   # Known safe development operation

  # Enable only specific built-in rules (omit to enable all 36 rules)
  # Useful if you only care about certain types of dangerous operations
  #
  # Available rules (36 total):
  #   Critical: rm-rf-root, disk-wipe, database-drop, git-force-push,
  #     terraform-destroy, kubectl-delete, aws-s3-delete,
  #     cloud-instance-terminate, curl-pipe-shell, aws-destructive,
  #     gcp-destructive, azure-destructive, heroku-destructive,
  #     redis-flush, cassandra-drop, crontab-remove, iptables-flush
  #   Warning: docker-system-prune, git-reset-hard, npm-uninstall-all,
  #     package-remove, chmod-777, firewall-flush, process-kill-force,
  #     helm-delete, ssh-key-delete, env-file-overwrite,
  #     git-branch-delete-force, git-reflog-expire,
  #     docker-swarm-destructive, podman-system-reset, pip-uninstall-all,
  #     go-clean-modcache, systemctl-critical-services, killall-force,
  #     deployment-commands
  #
  # Example: Only check for the most critical operations
  # enabled_rules:
  #   - rm-rf-root
  #   - database-drop
  #   - git-force-push
  #   - terraform-destroy
  #   - kubectl-delete

  # Custom rules - add project-specific dangerous patterns
  custom_rules:
    # Example 1: Production deployment detection
    - id: "prod-deploy"
      severity: critical  # critical, warning, or info
      patterns:
        - "kubectl apply.*production"
        - "kubectl apply.*prod"
        - "terraform apply.*prod"
        - "helm.*--namespace=production"
      description: "Deploying to production environment without review"
      suggestion: "Get team approval before production deployments. Use staging first."

    # Example 2: Database migrations in production
    - id: "prod-migration"
      severity: critical
      patterns:
        - "rails db:migrate.*RAILS_ENV=production"
        - "alembic upgrade head.*production"
        - "migrate.*--env=production"
      description: "Running database migrations in production"
      suggestion: "Backup database first. Test migration in staging. Have rollback plan ready."

    # Example 3: AWS resource deletion
    - id: "aws-resource-delete"
      severity: critical
      patterns:
        - "aws.*delete-.*"
        - "aws.*terminate-.*"
        - "aws s3 rm.*--recursive"
        - "aws rds delete-db-instance"
      description: "Deleting AWS resources (instances, databases, S3 buckets)"
      suggestion: "Verify resource names. Check for backups. Use AWS tags to protect critical resources."

    # Example 4: Container registry operations
    - id: "registry-cleanup"
      severity: warning
      patterns:
        - "docker.*rmi.*-f"
        - "docker image prune.*-a"
        - "gcr.io.*delete"
      description: "Removing Docker images or cleaning container registries"
      suggestion: "Verify you're not deleting production images. Check image tags carefully."

    # Example 5: Certificate/key operations
    - id: "cert-key-ops"
      severity: warning
      patterns:
        - "openssl.*-out.*key"
        - "rm.*\\.(pem|key|crt|p12|pfx)"
        - "vault.*delete.*secret"
      description: "Operations involving certificates or secret keys"
      suggestion: "Backup certificates before regenerating. Document key rotation procedures."

    # Example 6: Cache invalidation
    - id: "cache-invalidate"
      severity: warning
      patterns:
        - "redis-cli.*FLUSHALL"
        - "redis-cli.*FLUSHDB"
        - "memcached.*flush_all"
      description: "Invalidating entire cache (may cause performance degradation)"
      suggestion: "Warn team about cache flush. Monitor application performance after."

# Common Configuration Scenarios
#
# Scenario 1: Disable safety for experienced team (global ~/.lazymake.yaml)
# safety:
#   enabled: false
#
# Scenario 2: Enable only for critical operations (project .lazymake.yaml)
# safety:
#   enabled: true
#   enabled_rules:
#     - rm-rf-root
#     - database-drop
#     - terraform-destroy
#
# Scenario 3: Trust all cleanup targets (project .lazymake.yaml)
# safety:
#   exclude_targets:
#     - clean
#     - distclean
#     - purge
#     - reset
#     - nuke-dev
#     - nuke-test
#
# Scenario 4: Strict safety for production project (project .lazymake.yaml)
# safety:
#   enabled: true  # All built-in rules enabled
#   custom_rules:
#     - id: "any-prod-operation"
#       severity: critical
#       patterns: [".*prod.*", ".*production.*"]
#       description: "Any operation mentioning production"
#       suggestion: "Triple-check production operations"
#
# Scenario 5: Development-only project (project .lazymake.yaml)
# safety:
#   enabled: false  # Safe to disable for purely local dev projects

# Export Configuration
# Export execution results to JSON/log files for analysis and debugging
export:
  # Enable/disable execution result exports
  # Default: false (opt-in feature)
  enabled: false

  # Output directory for exported results
  # Supports ~ expansion and environment variables
  # Default: ~/.cache/lazymake/exports
  output_dir: ~/.cache/lazymake/exports

  # Export format: "json", "log", or "both"
  # - json: Structured data for programmatic analysis, CI/CD integration
  # - log: Human-readable text format for quick debugging
  # - both: Create both JSON and log files
  # Default: "json"
  format: json

  # File naming strategy: "timestamp", "target", or "sequential"
  # - timestamp: {target}_{timestamp}.json (e.g., build_20251212_143022.json)
  #   Best for historical analysis, keeps all execution records
  # - target: {target}_latest.json (overwrites previous for same target)
  #   Best for CI/CD where you only need latest result
  # - sequential: {target}_{N}.json (incremental numbering)
  #   Best for tracking execution series
  # Default: "timestamp"
  naming_strategy: timestamp

  # Rotation settings - cleanup old exports
  # All rotation settings default to 0 (disabled). Set non-zero values to enable.

  # Maximum file size in MB (default: 0 = unlimited)
  # Files exceeding this size are removed during rotation
  max_file_size_mb: 0

  # Maximum number of files to keep per target (default: 0 = unlimited)
  # Only applies when naming_strategy is "timestamp" or "sequential"
  # Older files are automatically deleted
  max_files: 0

  # Keep exports for N days (default: 0 = forever)
  # Files older than N days are automatically cleaned up
  keep_days: 0

  # Only export successful executions (ignore failures)
  # Default: false (export everything including failures)
  success_only: false

  # Don't export results for these targets
  # Useful for noisy/frequent targets like "test" or "watch"
  exclude_targets:
    - watch
    - dev
    - test-watch

# Shell Integration Configuration
# Add executed make commands to your shell history
shell_integration:
  # Enable/disable shell history integration
  # Default: false (opt-in feature)
  enabled: false

  # Shell type: "auto", "bash", "zsh", "fish", or "none"
  # - auto: Detect from $SHELL environment variable (recommended)
  # - bash: Force bash history format
  # - zsh: Force zsh history format (detects extended history automatically)
  # - fish: Force fish history format (- cmd: / when: entries)
  # - none: Disable shell integration
  # Default: "auto"
  shell: auto

  # Override shell history file path
  # Leave empty to use shell defaults:
  # - bash: ~/.bash_history
  # - zsh: ~/.zsh_history or $HISTFILE
  # - fish: ~/.local/share/fish/fish_history
  # Default: "" (use shell default)
  history_file: ""

  # Include timestamp in history entry (for shells that support it)
  # - zsh: auto-detects extended history format (setopt EXTENDED_HISTORY)
  #   and writes timestamped entries (: <timestamp>:0;command) when detected
  # - fish: writes the "when:" timestamp field in fish history format
  # - bash: no effect
  # When false, always writes plain entries regardless of shell.
  include_timestamp: true

  # Custom format template for history entries
  # Available variables: {target}, {makefile}, {dir}
  # Examples:
  # - "make {target}" (default, simple)
  # - "make -f {makefile} {target}" (includes makefile path)
  # - "cd {dir} && make {target}" (includes working directory)
  # Default: "make {target}"
  format_template: "make {target}"

  # Don't add these targets to shell history
  # Useful for meta-targets or help commands
  exclude_targets:
    - help
    - list

# Export Configuration Scenarios
#
# Scenario 1: Enable for CI/CD integration (export JSON only)
# export:
#   enabled: true
#   format: json
#   naming_strategy: target  # Overwrite latest result
#   success_only: true
#
# Scenario 2: Debugging with logs (keep recent executions)
# export:
#   enabled: true
#   format: both  # JSON + human-readable logs
#   max_files: 20
#   keep_days: 7
#
# Scenario 3: Long-term metrics collection
# export:
#   enabled: true
#   format: json
#   naming_strategy: timestamp
#   keep_days: 90  # Keep 3 months of data
#   exclude_targets:
#     - help
#     - list
#     - clean

# Shell Integration Scenarios
#
# Scenario 1: Enable for bash
# shell_integration:
#   enabled: true
#   shell: bash
#
# Scenario 2: Enable for zsh with extended history
# shell_integration:
#   enabled: true
#   shell: zsh
#   include_timestamp: true
#
# Scenario 3: Enable for fish with timestamps
# shell_integration:
#   enabled: true
#   shell: fish
#   include_timestamp: true
#
# Scenario 4: Custom format with context
# shell_integration:
#   enabled: true
#   format_template: "make -f {makefile} {target}"
#   exclude_targets:
#     - help
#     - list
#     - show-%
